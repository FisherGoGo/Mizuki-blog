---
title: 2025.4.28 线段树进阶题解
published: 2025-04-28
tags: [DS]
category: Tutorial
draft: false
---


# A

- 我们创建两颗线段树，每颗线段树就如它原本那样表示 l-r 的总节点
- 一棵树从父亲节点往儿子节点连边，另外一棵反过来连
- 同时我们在创建一套原始节点
- 这样操作一就是简单地在原始节点连边
- 操作二就是将原始节点往第一棵树连边，通过线段树优化我们只需要连 logn 条边
- 操作三就是第二棵树向原始节点连边
- 连完边后跑一边 Dij 即可
```cpp
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;
#define ll long long 
const int maxn=400010;

int n,q,s;

struct Edge{
    int u;
    int v;
    ll w;
    int nxt;
}edge[maxn*10];
int head[maxn*10],cnt;

void addedge(int u,int v,ll w){
    edge[++cnt].v=v;
    edge[cnt].u=u;
    edge[cnt].w=w;
    edge[cnt].nxt=head[u];
    head[u]=cnt;
    return ;
}

int leaf[maxn*10]; 

void build(int x,int l,int r){
    if(l==r){
        leaf[l]=x;
        addedge(x,l+8*n,0);
        addedge(l+8*n,x+4*n,0);
        return ;
    }
    addedge(x,x*2,0);
    addedge(x,x*2+1,0);
    addedge(x*2+4*n,x+4*n,0);
    addedge(x*2+1+4*n,x+4*n,0);
    build(x*2,l,(l+r)/2);
    build(x*2+1,(l+r)/2+1,r);
    return ;
}
//操作2
void add2(int x,int l,int r,int ql,int qr,int node,ll w){
    if(ql<=l&&r<=qr){
        addedge(node,x,w);
        return ;
    }
    int mid=(l+r)/2;
    if(ql<=mid) add2(x*2,l,mid,ql,qr,node,w);
    if(qr>mid) add2(x*2+1,mid+1,r,ql,qr,node,w);
    return ;
}
//操作3
void add3(int x,int l,int r,int ql,int qr,int node,ll w){
    if(ql<=l&&r<=qr){
        addedge(x+4*n,node,w);
        return ;
    }
    int mid=(l+r)/2;
    if(ql<=mid) add3(x*2,l,mid,ql,qr,node,w);
    if(qr>mid) add3(x*2+1,mid+1,r,ql,qr,node,w);
    return ;
}

struct node{
    ll dis;
    int u;
};
bool operator < (node a,node b){
    return a.dis>b.dis;
}
ll dis[maxn*10];
int vis[maxn*10];

void Dij(int s){
    priority_queue <node> q;
    memset(dis,0x3f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    dis[s]=0;
    q.push({0,s});
    while(!q.empty()){
        int u=q.top().u;
        q.pop();
        if(vis[u]) continue;
        vis[u]=1;
        for(int i=head[u];i;i=edge[i].nxt){
            int v=edge[i].v;
            ll w=edge[i].w;
            if(vis[v]) continue;
            if(dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                // cout<<dis[v]<<" "<<w<<endl;
                q.push({dis[v],v});
            }
        }
    }
}

int main(){
    cin>>n>>q>>s;
    build(1,1,n);
    for(int i=1;i<=q;i++){
        int tag,v,u,l,r;
        ll w;
        cin>>tag;
        if(tag==1){
            cin>>u>>v>>w;
            addedge(u+8*n,v+8*n,w);
        }
        if(tag==2){
            cin>>u>>l>>r>>w;
            add2(1,1,n,l,r,u+8*n,w);
        }
        if(tag==3){
            cin>>u>>l>>r>>w;
            add3(1,1,n,l,r,u+8*n,w);
        }
    }

    Dij(s+8*n);

    for(int i=1;i<=n;i++){
        if(dis[i+8*n]>=1e18) cout<<-1<<" ";
        else cout<<dis[i+8*n]<<" ";
    }

    return 0;
}
```

# B
- 建一棵权值线段树，从左往右加入数字，加入之前查询比它大的数有多少个统计即可
```cpp
#include<iostream>
#include<algorithm>
#define mid ((l)+(r)>>1)
using namespace std;
typedef long long ll;

const int maxn=1e7+8;
const ll lim=1e9;

ll d[maxn];
int ls[maxn],rs[maxn],node=0;
int rt=0;
int n;

void push_up(int x){
    d[x]=d[ls[x]]+d[rs[x]];
    return ;
}

void update(int &x,ll l,ll r,ll col){
    if(x==0) x=++node;
    if(l==r){
        d[x]++;
        return ;
    }

    if(col<=mid) update(ls[x],l,mid,col);
    else update(rs[x],mid+1,r,col);

    push_up(x);
}

ll query(int x,ll l,ll r,ll val){
    if(x==0) return 0;
    if(l>val) return d[x];

    ll res=0;
    if(val<=mid) res+=query(ls[x],l,mid,val);
    res+=query(rs[x],mid+1,r,val);

    return res;
}

  

int main(){
    cin>>n;
    
    ll ans=0;
    for(int i=1;i<=n;i++){
        ll x;
        cin>>x;
        update(rt,1,lim,x);
        ans+=query(rt,1,lim,x);
    }
    
    cout<<ans;
    return 0;
}
```

# C
- 用权值线段树维护序列中的数字，用flag来统计区间内存不存在仅出现一次的数，查询时尽可能往左查询
```cpp
#include<iostream>
#include<algorithm>
#define mid ((l)+(r)>>1)
using namespace std;
typedef long long ll;

const int maxn=1e7+8;
const ll lim=2e9;
const ll delta=1e9;

int d[maxn],ls[maxn],rs[maxn],flag[maxn],node=0;
ll a[maxn];
int rt=0;
int n,k;

void push_up(int x){
    d[x]=d[ls[x]]+d[rs[x]];
    flag[x]=flag[ls[x]]|flag[rs[x]];
    return ;
}

void update(int &x,ll l,ll r,int col,int val){
    if(x==0) x=++node;

    if(l==r){
        d[x]+=val;
        if(d[x]==1) flag[x]=1;
        else flag[x]=0;
        return ;
    }

    if(col<=mid) update(ls[x],l,mid,col,val);
    else update(rs[x],mid+1,r,col,val);

    push_up(x);
}

int query(int x,ll l,ll r){
    if(!flag[x]) return -1;
    if(l==r) return l;

    if(flag[rs[x]]) return query(rs[x],mid+1,r);
    else return query(ls[x],l,mid);
}

int main(){
    cin>>n>>k;

    for(int i=1;i<=n;i++) cin>>a[i],a[i]+=delta;
    for(int i=1;i<k;i++) update(rt,0,lim,a[i],1);
  
    for(int i=1;i<=n-k+1;i++){
        int j=i+k-1;
        update(rt,0,lim,a[j],1);
        int x=query(rt,0,lim);
        if(x==-1) cout<<"Nothing\n";
        else cout<<x-delta<<endl;
        update(rt,0,lim,a[i],-1);
    }
    return 0;
}
```

# D
- 我们用前缀和数组来转化原始数组，这样询问就转化成 a_r-a_l-1<t 的数有多少，既 a_r<t+a_l-1
- 我们前缀和转化完后从右往左加入数字，并同时查询 1-(a_i-1+t)中有多少个数
- 还有题目中会出现负数，我们给所有数加一个 1e9 就行
```cpp
#include<iostream>
#include<algorithm>
#define mid ((l)+(r)>>1)
using namespace std;
typedef long long ll;

const int maxn=1e7+8;
const ll lim=2e15;
const ll delta=1e15;

ll d[maxn];
int ls[maxn],rs[maxn],node=0;
int rt=0;
int n;
ll t;
ll a[maxn];

void push_up(int x){
    d[x]=d[ls[x]]+d[rs[x]];
    return ;
}

void update(int &x,ll l,ll r,ll col){
    if(x==0) x=++node;
    if(l==r){
        d[x]++;
        return ;
    }

    if(col<=mid) update(ls[x],l,mid,col);
    else update(rs[x],mid+1,r,col);

    push_up(x);
}

ll query(int x,ll l,ll r,ll ql,ll qr){
    if(x==0) return 0;
    if(l>=ql&&r<=qr) return d[x];

    ll res=0;
    if(ql<=mid) res+=query(ls[x],l,mid,ql,qr);
    if(qr>mid) res+=query(rs[x],mid+1,r,ql,qr);

    return res;
}

int main(){

    cin>>n>>t;

    for(int i=1;i<=n;i++){
        cin>>a[i];
    }

    for(int i=1;i<=n;i++) a[i]+=a[i-1];

    ll ans=0;
    for(int i=n;i>=1;i--){
        update(rt,1,lim,a[i]+delta);
        ans+=query(rt,1,lim,1,a[i-1]+t+delta-1);
    }
    
    cout<<ans;
    
    return 0;
}
```

# E

- 我们把问题转化成树上差分，既 a-b 的路径上加一袋 z 救济粮变成 a和b加一袋，lca(a,b) 和 fa(lca(a,b)) 减一袋，对每一个节点用一颗权值线段树维护，处理完后从叶子节点向上递归合并即可，边合并边查询
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#define mid ((l)+(r)>>1)
using namespace std;
const int maxn=2e6;

struct Edge{
    int u,v,nxt;
}edge[maxn*2];
int cnt,head[maxn];
void addedge(int u,int v){
    edge[++cnt]={u,v,head[u]};
    head[u]=cnt;
}

int n,m;
int X[maxn],Y[maxn],Z[maxn];
int lim=0;

//LCA
int dep[maxn],fa[maxn][32];
void dfs(int x,int Fa){
    dep[x]=dep[Fa]+1;
    fa[x][0]=Fa;
    for(int i=1;(1<<i)<=dep[x];i++){
        fa[x][i]=fa[fa[x][i-1]][i-1];
    }
    for(int i=head[x];i;i=edge[i].nxt){
        if(edge[i].v!=Fa)
        dfs(edge[i].v,x);
    }
}

int lca(int x,int y){
    if(dep[x]<dep[y]) swap(x,y);
    for(int i=31;i>=0;i--){
        if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];
        if(x==y) return x;
    }
    for(int i=31;i>=0;i--){
        if(fa[x][i]!=fa[y][i]){
            x=fa[x][i];
            y=fa[y][i];
        }
    }
    return fa[x][0];
}

//Segment_Tree
int d[maxn*4],t[maxn*4],ls[maxn*4],rs[maxn*4],rt[maxn],node;
int Ans[maxn];

void push_up(int x){
    if(d[ls[x]]>=d[rs[x]]) d[x]=d[ls[x]],t[x]=t[ls[x]];
    else d[x]=d[rs[x]],t[x]=t[rs[x]];
}

void update(int &x,int l,int r,int pos,int val){
    if(!x) x=++node;
    if(l==r){
        d[x]+=val;
        t[x]=l;
        return ;
    }
  
    if(pos<=mid) update(ls[x],l,mid,pos,val);
    else update(rs[x],mid+1,r,pos,val);
    push_up(x);
    return ;
}

int merge(int a,int b,int l,int r){
    if(!a||!b) return a|b;
    if(l==r){
        d[a]+=d[b];
        t[a]=l;
        return a;
    }
  
    ls[a]=merge(ls[a],ls[b],l,mid);
    rs[a]=merge(rs[a],rs[b],mid+1,r);

    push_up(a);
    return a;
}

  

void Merge_dfs(int x,int F){
    for(int i=head[x];i;i=edge[i].nxt){
        int v=edge[i].v;
        if(v==F) continue;
        Merge_dfs(v,x);
        rt[x]=merge(rt[x],rt[v],1,lim);
        // if(d[rt[x]]) Ans[x]=t[rt[x]];
    }
    if(d[rt[x]]>0) Ans[x]=t[rt[x]];
    // cout<<d[rt[x]]<<endl;
}

int main(){
    cin>>n>>m;
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        addedge(u,v);
        addedge(v,u);
    }
    dfs(1,0);

    for(int i=1;i<=m;i++){
        cin>>X[i]>>Y[i]>>Z[i];
        lim=max(lim,Z[i]);
    }

    for(int i=1;i<=m;i++){
        int Lca=lca(X[i],Y[i]);
        update(rt[X[i]],1,lim,Z[i],1);
        update(rt[Y[i]],1,lim,Z[i],1);
        update(rt[Lca],1,lim,Z[i],-1);
        if(fa[Lca][0]) update(rt[fa[Lca][0]],1,lim,Z[i],-1);
    }

    Merge_dfs(1,0);

    for(int i=1;i<=n;i++) cout<<Ans[i]<<endl;

    return 0;
}
```

# F
- 用并查集和线段树合并维护
- 在建 u和v 的桥时，我们把u和v合并到一个并查集里，并把v的线段树数据合并到u上，查询时查询给定节点的父亲节点线段树数据即可
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#define mid ((l)+(r)>>1)
using namespace std;
const int maxn=2e6;

int d[maxn*4],ls[maxn*4],rs[maxn*4],rt[maxn],node;
int fa[maxn*4];
int ch[maxn*4][2];
int rnk[maxn];
int ans[maxn];
int n,m;

int find(int x){
    if(x!=fa[x]) return fa[x]=find(fa[x]);
    else return x;
}

void update(int &x,int pos,int l,int r){
    if(!x) x=++node;
    d[x]=1;
    if(l==r) return ;
    if(pos<=mid)  update(ls[x],pos,l,mid);
    else update(rs[x],pos,mid+1,r);
    return ;
}

int merge(int x,int y,int l,int r){
    if(!x||!y) return x|y;
    int z=++node;
    d[z]=d[x]+d[y];
    if(l==r) return z;
    ls[z]=merge(ls[x],ls[y],l,mid);
    rs[z]=merge(rs[x],rs[y],mid+1,r);
    return z;
}

int Query(int x,int rk,int l,int r){
    if(d[x]<rk) return -1;
    if(l==r){
        return ans[l];
    }
    if(d[ls[x]]>=rk) return Query(ls[x],rk,l,mid);
    else return Query(rs[x],rk-d[ls[x]],mid+1,r);
}

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>rnk[i];
        fa[i]=i;
        update(rt[i],rnk[i],1,n);
        ans[rnk[i]]=i;
    }

    for(int i=1;i<=m;i++){
        int u,v;
        cin>>u>>v;
        int fu=find(u),fv=find(v);
        if(fu!=fv){
            fa[fu]=fv;
            rt[fv]=merge(rt[fu],rt[fv],1,n);
        }
    }

    int q;
    cin>>q;
    for(int i=1;i<=q;i++){
        char c;
        cin>>c;
        int u,v;
        cin>>u>>v;
        if(c=='Q'){
            cout<<Query(rt[find(u)],v,1,n)<<endl;
        }
        else {
            int fu=find(u),fv=find(v);
            if(fu!=fv){
                fa[fu]=fv;
                rt[fv]=merge(rt[fu],rt[fv],1,n);
            }
        }
    }
}
```

# G

- 这个问题变成先找有没有距离自己为p的父亲，然后如果有再找这个父亲距离p的儿子有多少个，答案就是这个值减去1
- 那么就明朗了，我们从根开始跑dfs，边跑边对每一个点建一棵树，然后我们再递归回去的时候合并子儿子，查询的时候就是查询上述值就行
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<cmath>
#include<vector>
#define f(i,a,b) for(int i=a;i<=b;i++)
#define mid (l+r)/2
using namespace std;
typedef long long ll;
int t=1;
const int N=1e5+6;

int n;
vector <int> son[2*N];
int fa[200005][20];
int d[N*64];
int ls[N*64],rs[N*64];
int rt[200005],node=0;
int dep[200005];

int merge(int x,int y,int l,int r){
    if(!x||!y) return x|y;
    int z=++node;
    ls[z]=merge(ls[x],ls[y],l,mid);
    rs[z]=merge(rs[x],rs[y],mid+1,r);
    d[z]=d[x]+d[y];
    return z;
}

void update(int &x,int l,int r,int pos){
    if(x==0) x=++node;
    d[x]=1;
    if(l==r){
        return ;
    }

    if(pos<=mid) update(ls[x],l,mid,pos);
    else update(rs[x],mid+1,r,pos);

    // push_up(x);
}

int query(int x,int l,int r,int pos){
    if(l==r) return d[x];
    if(pos<=mid) return query(ls[x],l,mid,pos);
    else return query(rs[x],mid+1,r,pos);
}

void dfs(int x){
    dep[x]=dep[fa[x][0]]+1;
    update(rt[x],1,N,dep[x]);
    f(i,1,16) fa[x][i]=fa[fa[x][i-1]][i-1];
    for(auto v:son[x]) dfs(v),rt[x]=merge(rt[x],rt[v],1,N);
}

int find(int x,int K){
    for(int i=16;i>=0;i--){
        if(K>>i&1) x=fa[x][i];
    }
    return x;
}

void solve(){
    cin>>n;
    f(i,1,n){
        int f;
        cin>>f;
        son[f].push_back(i);
        fa[i][0]=f;
    }

    dfs(0);
    int q;
    cin>>q;

    while(q--){
        int u,p;
        cin>>u>>p;
        u=find(u,p);
        if(u==0) cout<<0<<" ";
        else {
            cout<<query(rt[u],1,N,dep[u]+p)-1<<" ";
        }
    }
}

int main(){
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    // cin>>t;
    while(t--) solve();
    return 0;
}
```

# H

- 用线段树维护 x 轴，再用权值线段树维护每个 y 轴，再用标记永久化维护，放每一个方块时查询放置区间内的最大值，然后再进行修改，最后在整个矩形内查询
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#define mid ((l)+(r)>>1)
#define ls (l+r)*2
#define rs (l+r)*2+1
using namespace std;
const int maxn=2e7;

int n,m,q;

// Segy
int d1[maxn],laz[maxn],node1;
int ls1[maxn],rs1[maxn];
void modify(int &x,int l,int r,int ql,int qr,int val){
    if(!x) x=++node1;
    laz[x]=max(laz[x],val);
    if(ql<=l&&r<=qr){
        d1[x]=max(val,d1[x]);
        return ;
    }
    if(ql<=mid) modify(ls1[x],l,mid,ql,qr,val);
    if(qr>mid) modify(rs1[x],mid+1,r,ql,qr,val);
}

int query(int x,int l,int r,int ql,int qr){
    if(!x) return 0;
    if(ql<=l&&r<=qr){
        return max(laz[x],d1[x]);
    }
    int res=d1[x];
    if(ql<=mid) res=max(res,query(ls1[x],l,mid,ql,qr));
    if(qr>mid) res=max(res,query(rs1[x],mid+1,r,ql,qr));
    return res;
}

//Segx
int d2[maxn],laz2[maxn];
void Modify(int x,int l,int r,int ql,int qr,int toql,int toqr,int val){
    modify(laz2[x],1,m,toql,toqr,val);
    if(ql<=l&&r<=qr){
        modify(d2[x],1,m,toql,toqr,val);
        return ;
    }
    if(ql<=mid) Modify(ls,l,mid,ql,qr,toql,toqr,val);
    if(mid<qr) Modify(rs,mid+1,r,ql,qr,toql,toqr,val);
}

int Query(int x,int l,int r,int ql,int qr,int toql,int toqr){
    int res=query(d2[x],1,m,toql,toqr);
    if(ql<=l&&r<=qr){
        return max(res,query(laz2[x],1,m,toql,toqr));
    }
    if(ql<=mid) res=max(res,Query(ls,l,mid,ql,qr,toql,toqr));
    if(mid<qr) res=max(res,Query(rs,mid+1,r,ql,qr,toql,toqr));
    return res;
}

int main(){
    cin>>n>>m>>q;
    for(int i=1;i<=q;i++){
        int d,s,w,x,y;
        cin>>d>>s>>w>>x>>y;
        int height=Query(1,1,n,x+1,x+d,y+1,y+s);
        Modify(1,1,n,x+1,x+d,y+1,y+s,height+w);
    }
    cout<<Query(1,1,n,1,n,1,m);
    return 0;
}
```

# I
- 对于每一个位置的数 a_i 转化为点对 (i,a_i) 在二维平面上，这样子查询 a_i 的逆序对就变成了查询矩形 (1,a_i+1),(i-1,lim) 和矩形 (i+1,a_i-1),(n,1) 两个平面上的点对数有多少，同 G 题，不过我们可以用树状数组来维护 x 轴，用权值线段树来维护 y 轴
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#define mid ((l)+(r)>>1)
using namespace std;
const int maxn=2e7;
typedef long long ll;

ll d[maxn];
int ls[maxn],rs[maxn],node;
int n,m;
int t[maxn],rnk[maxn],a[maxn];
ll ans=0;

void update(int &x,int l,int r,int p,int val){
    if(!x) x=++node;
    d[x]+=val;
    if(l==r) return ;
    if(p<=mid) update(ls[x],l,mid,p,val);
    else update(rs[x],mid+1,r,p,val);
}

ll query(int x,int l,int r,int ql,int qr){
    if(ql<=l&&qr>=r) return d[x];
    ll res=0;
    if(ql<=mid) res+=query(ls[x],l,mid,ql,qr);
    if(mid<qr) res+=query(rs[x],mid+1,r,ql,qr);
    return res;
}

void t_update(int x,int p,int val){
    while(x<=n){
        update(t[x],1,n,p,val);
        x+=x&(-x);
    }
}

ll t_query(int x,int ql,int qr){
    ll res=0;
    while(x){
        res+=query(t[x],1,n,ql,qr);
        x-=x&(-x);
    }
    return res;
}

ll Query(int xl,int xr,int ql,int qr){
    if(ql>qr) return 0;
    else {
        return t_query(xr,ql,qr)-t_query(xl-1,ql,qr);
    }
}

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        rnk[a[i]]=i;
        t_update(i,a[i],1);
    }
    for(int i=2;i<=n;i++){
        ans+=Query(1,i-1,a[i]+1,n);
    }
    for(int i=1;i<=m;i++){
        int p;
        cin>>p;
        p=rnk[p];
        cout<<ans<<endl;
        ans-=Query(1,p-1,a[p]+1,n)+Query(p+1,n,1,a[p]-1);
        t_update(p,a[p],-1);
    }
}
```

# J
- 判断二分图可以用扩展域并查集，由于要支持撤销所以不能路径压缩，而应按秩合并（和可持久化并查集差不多的注意点）
- 
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>
#define mid ((l)+(r)>>1)
#define ls ((l+r)*2)
#define rs ((l+r)*2+1)
using namespace std;

const int maxn=1e5;

int n,m,k;
int fa[maxn],height[maxn];

struct Edge{
    int u,v;
}e[maxn];
struct stk{
    int u,v,add;
}st[maxn];
int top=0;
vector <int> t[maxn];

int find(int x){
    while(x!=fa[x]) x=fa[x];
    return fa[x];
}

void merge(int x,int y){
    int fx=find(x),fy=find(y);
    if(height[fx]>height[fy]) swap(fx,fy);
    st[++top]={fx,fy,height[fx]==height[fy]};
    fa[fx]=fy;
    if(height[fx]==height[fy]) height[fy]++;
}

void update(int x,int l,int r,int ql,int qr,int val){
    if(ql<=l&&r<=qr){
        t[x].push_back(val);
        return ;
    }

    if(ql<=mid) update(ls,l,mid,ql,qr,val);
    if(qr>mid) update(rs,mid+1,r,ql,qr,val);
}

void query(int x,int l,int r){
    int ans=1;
    int lasttop=top;
    for(int i=0;i<t[x].size();i++){
        int fu=find(e[t[x].at(i)].u);
        int fv=find(e[t[x].at(i)].v);
        if(fu==fv){
            for(int k=l;k<=r;k++) cout<<"NO\n";
            ans=0;
            break;
        }
        merge(e[t[x].at(i)].u,e[t[x].at(i)].v+n);
        merge(e[t[x].at(i)].v,e[t[x].at(i)].u+n);
    }
    if(ans){
        if(l==r) cout<<"YES\n";
        else {
            query(ls,l,mid);
            query(rs,mid+1,r);
        }
    }
    while(top>lasttop){
        height[fa[st[top].u]]-=st[top].add;
        fa[st[top].u]=st[top].u;
        top--;
    }
    return ;
}

int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++){
        cin>>e[i].u>>e[i].v;
        int l,r;
        cin>>l>>r;
        l++;
        update(1,1,k,l,r,i);
    }
    for(int i=1;i<=2*n;i++) fa[i]=i,height[i]=1;
  
    query(1,1,k);

    return 0;
}
```

# K

- 正解平衡树，但是我们也可以用权值线段树来完成这些操作
- 插入删除正常操作
- 找x的排位即是找 1-(x-1) 中有多少个数
- 找第k大见代码
- 找前驱先尽量在不超过给定值的区间内往右找
- 找后驱则反过来

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<cmath>
#include<vector>
#define f(i,a,b) for(int i=a;i<=b;i++)
#define mid (l+r)/2
using namespace std;
typedef long long ll;
int t=1;
const int N=2e5;

int d[N*10],ls[N*10],rs[N*10];
int n;
int node=0;
int rt=0;
int lim=2e7+10;
int delta=1e7+1;

void push_up(int x){
    d[x]=d[ls[x]]+d[rs[x]];
    return ;
}

void update(int &x,int l,int r,int pos,int val){
    if(x==0) x=++node;
    if(l==r){
        d[x]+=val;
        return ;
    }

    if(pos<=mid) update(ls[x],l,mid,pos,val);
    else update(rs[x],mid+1,r,pos,val);

    push_up(x);
}

int query_cnt(int x,int l,int r,int pos){
    if(x==0) return 0;
    if(r<=pos) return d[x];

    int ret=0;
    ret+=query_cnt(ls[x],l,mid,pos);
    if(pos>mid) ret+=query_cnt(rs[x],mid+1,r,pos);
    return ret;
}

int query_rk(int x,int l,int r,int rk){
    if(l==r) return l;
    if(rk<=d[ls[x]]) return query_rk(ls[x],l,mid,rk);
    else return query_rk(rs[x],mid+1,r,rk-d[ls[x]]);
}

int find_pre(int x,int l,int r){
    if(l==r) return l;
    if(d[rs[x]]) return find_pre(rs[x],mid+1,r);
    else return find_pre(ls[x],l,mid);
}

int query_pre(int x,int l,int r,int pos){
    if(r<pos){
        if(d[x]) return find_pre(x,l,r);
        else return 0;
    }
    else if(pos>mid+1&&d[rs[x]]){
        int res=query_pre(rs[x],mid+1,r,pos);
        if(res) return res;
    }
    return query_pre(ls[x],l,mid,pos);
}

int find_back(int x,int l,int r){
    if(l==r) return l;
    if(d[ls[x]]) return find_back(ls[x],l,mid);
    else return find_back(rs[x],mid+1,r);
}

int query_back(int x,int l,int r,int pos){
    if(l>pos){
        if(d[x]) return find_back(x,l,r);
        else return 0;
    }
    else if(pos<=mid&&d[ls[x]]){
        int res=query_back(ls[x],l,mid,pos);
        if(res) return res;
    }
    return query_back(rs[x],mid+1,r,pos);
}

void solve(){
    cin>>n;
    f(i,1,n){
        int opt,x;
        cin>>opt>>x;
        x+=delta;
        // cout<<opt<<":";
        if(opt==1) update(rt,1,lim,x,1);
        if(opt==2) update(rt,1,lim,x,-1);
        if(opt==3) cout<<query_cnt(rt,1,lim,x-1)+1<<"\n";
        if(opt==4) cout<<query_rk(rt,1,lim,x-delta)-delta<<"\n";
        if(opt==5) cout<<query_pre(rt,1,lim,x)-delta<<"\n";
        if(opt==6) cout<<query_back(rt,1,lim,x)-delta<<"\n";
    }
}



int main(){
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    // cin>>t;
    while(t--) solve();
    return 0;
}
```

- 下平衡树正解
```cpp
#include<iostream>
#include<algorithm>
#include<random>
using namespace std;

std::mt19937 rnd(233);

struct Tree{
    int l,r;
    int val,key;
    int size;
}fhq[100005];
int cnt,root;

void update(int now){
    fhq[now].size=fhq[fhq[now].l].size+fhq[fhq[now].r].size+1;
    return ;
}

int newnode(int val){
    fhq[++cnt].val=val;
    fhq[cnt].key=rnd();
    fhq[cnt].size=1;
    return cnt;
}

void split(int now,int val,int &x,int &y){
    if(!now) x=0,y=0;
    else {
        if(fhq[now].val<=val){
            x=now;
            split(fhq[now].r,val,fhq[now].r,y);
        }
        else {
            y=now;
            split(fhq[now].l,val,x,fhq[now].l);
        }
        update(now);
    }
    return ;
}

int merge(int x,int y){
    if(!x||!y) return x+y;
    if(fhq[x].key>fhq[y].key){
        fhq[x].r=merge(fhq[x].r,y);
        update(x);
        return x;
    }
    else {
        fhq[y].l=merge(x,fhq[y].l);
        update(y);
        return y;
    }
}

int x,y,z;

void insert(int val){
    split(root,val,x,y);
    root=merge(merge(x,newnode(val)),y);
    return ;
}

void del(int val){
    split(root,val,x,z);
    split(x,val-1,x,y);
    y=merge(fhq[y].l,fhq[y].r);
    root=merge(merge(x,y),z);
    return ;
}

void getrank(int val){
    split(root,val-1,x,y);
    cout<<fhq[x].size+1<<endl;
    root=merge(x,y);
    return ;
}

void getnum(int rank){
    int now=root;
    while(now){
        if(fhq[fhq[now].l].size+1==rank) break;
        else if(fhq[fhq[now].l].size>=rank) now=fhq[now].l;
        else {
            rank-=fhq[fhq[now].l].size+1;
            now=fhq[now].r;
        }
    }
    cout<<fhq[now].val<<endl;
    return ;
}

void pre(int val){
    split(root,val-1,x,y);
    int now=x;
    while(fhq[now].r){
        now=fhq[now].r;
    }
    cout<<fhq[now].val<<endl;
    root=merge(x,y);
    return ;
}

void nxt(int val){
    split(root,val,x,y);
    int now=y;
    while(fhq[now].l) now=fhq[now].l;
    cout<<fhq[now].val<<endl;
    root=merge(x,y);
    return ;
}

int main(){
    int n;
    cin>>n;
    while(n-->0){
        int opt,x;
        cin>>opt>>x;
        if(opt==1) insert(x);
        else if(opt==2) del(x);
        else if(opt==3) getrank(x);
        else if(opt==4) getnum(x);
        else if(opt==5) pre(x);
        else if(opt==6) nxt(x);
    }
    return 0;
}
```