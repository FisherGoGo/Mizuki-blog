---
title: 快速傅里叶变换と快速数论变换
published: 2025-07-26
tags: [MATH]
category: Knowledge
draft: false
---

# 多项式

## 系数表示法

- 对于一个**次数界**（最高次数小于 $n$ ）的多项式 $A(x)$ 可以写为
$$A(x)=a_{0}+a_{1}x+a_{2}x^{2}+..+a_{n-1}x^{n-1}=\sum\limits_{j=0}^{n-1} a_{j}x^{j}$$
- 这个表示法可以由向量 $a=(a_{0},a_{1},a_{2},...,a_{n-1})$ 唯一确定
- 对于求值，我们可以用**霍纳法则**在 $O(n)$ 内算出
$$A(x_{0})=a_{0}+x_{0}(a_{1}+x_{0}(a_{2}+..+x_{0}(a_{n-2}+x_{0}a_{n-1})...))$$
- 对于算加法，我们逐次相加，既 $c_{j}=a_{j}+b_{j}$ ，复杂度也是 $O(n)$ 
- 但是对于乘法，复杂度来到了 $O(n^{2})$ ，因为 $C(x)=A(x)B(x)$ 是一个次数界为 $2n-1$ 的多项式，其中系数
$$c_{k}=\sum\limits_{i=0}^{k} a_{i}b_{k-i}$$
## 点值表示法

- 一个次数界为 $n$ 的多项式 $A(x)$ 可以由它在 $n$ 个不同点 $x_{0},x_{1},...,x_{n-1}$ 处的取值唯一确定，可以表示为有 $n$ 个点值对组成的集合
$$\{(x_{0},y_{0}),(x_{1},y_{1}),...,(x_{n-1},y_{n-1})\}$$
- 其中 $y_{k}=A(x_{k})$ ，且若保证 $n$ 个点的 $x_{k}$ 互不相同，那么存在唯一一个次数界为 $n$ 的多项式穿过这些点
- 对于算加法，复杂度为 $O(n)$ ，既 $\{(x_{k},A(x_{k})+B(x_{k}))\}$ 
- 对于算乘法，复杂度也为 $O(n)$ ，既 $\{(x_{k},A(x_{k})\cdot B(x_{k})\}$
- 如果 $A(x)$ 与 $B(x)$ 的次数界都为 $n$ ，那么 $C(x)$ 的次数界为 $2n-1$ ，那么我们需要至少 $2n-1$ 个点值对，所以我们要为它们准备扩展的点值表示，我们一般选择 $2^{k}\ge 2n-1$ 个点进行求值

## 转化与问题

- 我们发现我们貌似可以利用点值表示法来加速乘法，有以下步骤：
	- **求值**：将多项式 $A(x),B(x)$ 转化为点值表示
	- **逐项相乘**：在 $O(n)$ 内算出 $C(x)$ 的点值表示
	- **插值**：将 $C(x)$ 的点值表示转换回系数表示，最终得到答案
- 步骤一和步骤二的复杂度都来到了 $O(n^{2})$ ，如果我们能加速这个过程，那么整个算数过程也可以被加速，这正是 $\mathbf{FFT}$ 与 $\mathbf{NTT}$ 所要做到的事 

# 卷积

- 卷积是一个运算，有许多卷积，包括之前的迪利克雷卷积，这里我们来定义离散卷积
- 对于两个序列（或者向量）$a=(a_{0},a_{1},a_{2},...,a_{n-1})$ 与 $b=(b_{0},b_{1},b_{2},...,b_{n-1})$ ，它们的线性卷积我们记作 $c=a\otimes b$ ，得到一个新的序列 $c$ ，其中有
$$c_{k}=\sum\limits_{i+j=k} a_{i}b_{j}=\sum\limits_{i=0}^{k} a_{i}b_{k-i}$$
- 得到新序列的长度为 $n+m-1$ ，当索引超出范围时，我们假设值为 $0$ 
- 直观地看，我们将序列 $b$ 反转，然后向右平移 $k$ 个单位再与 $a$ 对齐，然后计算重叠部分的逐个元素乘积之和

## 多项式乘法与卷积

- 两个多项式 $A(x)=\sum\limits a_{i}x^{i}$ 与 $B(x)=b_{j}x^{j}$ 的乘积是
$$C(x) = A(x)B(x) = \left(\sum_{i=0}^{n-1} a_i x^i\right) \left(\sum_{j=0}^{m-1} b_j x^j\right) = \sum_{i=0}^{n-1} \sum_{j=0}^{m-1} a_i b_j x^{i+j}$$
- 其中 $x^{k}$ 的系数为
$$c_k = \sum_{i+j=k} a_i b_j$$
- 这正与离散卷积定义完全一致
- 那我们可以发现**多项式乘法问题**本质就是其**系数向量的卷积问题**，所以我们为加速多项式乘法而开发的算法实际上都是**快速卷积算法**

# 快速傅里叶变换

- 我们已经知道加速多项式乘法的关键在于系数表示与点值表示之间的快速转化，快速傅里叶变换的核心思想就是不任意选择求值点，而是选择一组具有高度对称性的特殊点，既**单位复数根**，从而用分治策略将复杂度降到 $O(n\log n)$ 

## 复数与单位根

### 复数：

- 形如 $a+bi$ 的数为复数，其中 $i^{2}=-1$ ，我们可以在以恶搞二维复平面表示它，其中 $x$ 轴为实部，$y$ 轴为虚部
### 欧拉公式：

- 我们有欧拉公式，是连接复指数与三角函数的桥梁
$$e^{i\theta}=\cos\theta+i\sin\theta$$
- 它表示复平面上单位圆上一个与正实轴夹角为 $\theta$ 的点
### $n$ 次单位根

- 方程 $z^{n}=1$ 在复数域中所有的解被称为 $n$ 次单位根，这个方程恰好有 $n$ 个解，可以表示为
$$\omega_{n}^{k}=e^{2\pi ik / n}\quad k=0,1,...,n-1$$
- 其中 $w_{n}^{k}$ 为第 $k$ 个 $n$ 次单位根，当 $k=1$ 时我们得到主 $n$ 次单位根，几何上这几个根均匀分布在复平面的单位圆上，构成一个正 $n$ 边形的顶点

### 单位根的关键性质

- 周期性： $\omega _{n}^{k+n}=\omega_{n}^{k}\cdot \omega_{n}^{n}=\omega_{n}^{k}$
- 相消引理：对于任意整数 $d,n,k>0$ ，有 $\omega_{dn}^{dk}=\omega_{n}^{k}$
- 折半引理：如果 $n$ 是偶数，那么所有 $n$ 次单位根的平方，恰好构成了 $\frac{n}{2}$ 次单位根的集合，并且每个 $\frac{n}{2}$ 次单位根都出现恰好两次，既 $(\omega_{n}^{k})^{2}=\omega_{\frac{n}{2}}^{k}$ 
- 对称性：如果 $n$ 是偶数，那么对于 $k< n/2$ 有
$$ \omega_n^{k + n/2} = e^{2\pi i (k+n/2)/n} = e^{2\pi i k/n} \cdot e^{\pi i} = \omega_n^k \cdot (-1) = -\omega_n^k $$
- 这个性质至关重要，它提供了分治所需要的 $+x$ 与 $-x$ 的配对关系
- 有一个初步想法：我们可以选取成对的求值点 $\{\pm x_{0},\pm x_{1},...\}$ 来加速计算，既对于一个多项式 $A(x)$ ，我们将其分解为偶数次项与奇数次项：
$$A(x)=(a_{0}+a_{2}x^{2}+...)+x(a_{1}+a_{3}x^{2}+...)=A_{even}(x^{2})+xA_{odd}(x^{2})$$
- 这样计算 $A(x)$ 与 $A(-x)$ 变成了：
$$\begin{cases}A(x)=A_{even}(x^{2})+x\cdot A_{odd}(x^{2})\\\\A(-x)=A_{even}(x^{2})-x\cdot A_{odd}(x^{2})\end{cases}$$
- 这样子我们只需要计算两个子问题的答案就可以得到原问题的两个答案，既我们算 $A_{even}$ 与 $A_{odd}$ 的复杂度都是 $O\left( \frac{n}{2} \right)$ 的，但是算 $A(x)$ 与算 $A(-x)$ 是 $O(n)$ 的，所以有
$$T(n)=2T\left( \frac{n}{2} \right)+O(n)$$
- 得到解为 $O(n\log n)$ ，而单位根的对称性正给了我们分治的条件

## FFT的核心：分治法

- 假如我们要计算次数界为 $n$ （我们这里设 $n=2^{k}$ ）的多项式在 $n$ 个 $n$ 次单位根 $\omega_{n}^{0},\omega_{n}^{1}...$ 上的值，这个过程被称为**离散傅里叶变换（DFT）** 
- 我们将 $A(x)$ 按系数的奇偶下标分为两个子多项式 
$$\begin{cases}A_{even}(y)=a_{0}+a_{2}y+a_{4}y^{2}+...+a_{n-2}y^{n/2-1}\\\\A_{odd}(y)=a_{1}+a_{3}y+a_{5}y^{2}+....+a_{n-1}y^{n/2-1}\end{cases}$$
- 那么 $A(x)=A_{even}(x^{2})+x\cdot A_{odd}(x^{2})$ 
- 性质我们要在 $\omega_{n}^{k}$ 处求值，考虑求前半部分，既 $k=0,1,..., n/2-1$ 
$$A(\omega_{n}^{k})=A_{even}((\omega_{n}^{k})^{2})+\omega_{n}^{k}\cdot A_{odd}((\omega_{n}^{k})^{2})$$
- 利用折半原理，我们变成
$$y_{k}=A(\omega_{n}^{k})=A_{even}\left( \omega_{\frac{n}{2}}^{k} \right)+\omega_{n}^{k}\cdot A_{odd}\left( \omega_{\frac{n}{2}}^{k} \right)$$
- 接下来考虑求后半部分，既计算 $A(\omega_{n}^{k+n/2})$ ， $k=0,1,..., n/2-1$ ，我们利用对称性与折半原理，得到：
$$y_{k+n/2} = A(\omega_n^{k+n/2}) = A_{even}((\omega_n^{k+n/2})^2) + \omega_n^{k+n/2} \cdot A_{odd}((\omega_n^{k+n/2})^2) $$
$$ y_{k+n/2} = A_{even}(\omega_{n/2}^k) - \omega_n^k \cdot A_{odd}(\omega_{n/2}^k)$$
- 这两个式子是 **FFT** 的核心，

### 蝴蝶操作

- 对于合并分治的结果我们称为**蝴蝶操作**，我们令 $E_{k}=A_{even}\left( \omega_{\frac{n}{2}}^{k} \right)$ ，$O_{k}=A_{odd}\left( \omega_{\frac{n}{2}}^{k} \right)$ ，以及旋转因子 $t=\omega_{n}^{k}$ ，那么合并操作就是
$$y_{k}=E_{k}+t\cdot O_{k}$$
$$y_{k+\frac{n}{2}}=E_{k}-t\cdot O_{k}$$
## 逆变化 IFFT

- 现在我们完成了第一步，还有最后一步，从点值回到系数，这个过程称为**逆快速傅里叶变换 IFFT**
- DFT 过程可以被看作为一个矩阵向量乘法 $y=Va$ ，其中 $a$ 为系数向量，$y$ 是点值向量，而 $V$ 是一个范德蒙德矩阵，其元素为 $V_{jk}=(\omega_{n}^{jk})$ ，插值就是要计算 $a=V^{-1}y$ 
- 可以证明逆矩阵 $V^{-1}$ 的元素为 $(V^{-1})_{jk}=\frac{1}{n}\omega_{n}^{-jk}$
- 我们发现其与原矩阵 $V$ 非常相似，计算 $V^{-1}y$ 的过程，除了最后要除一个 $n$ 之外，就是我们把 $\omega_{n}^{-1}$ 来替换 $\omega_{n}$ 来做一次 DFT ，而 $\omega_{n}^{-1}=\omega_{n}^{n-1}$ ，它本身也是一个主 $n$ 次单位根，因此其过程与 DFT基本上一样，只需要两步修改：
	- 把单位根 $\omega_{n}^{k}$ 换成其共轭（或者逆元）$\omega_{n}^{-k}$
	- 将计算出来的结果向量每个元素都除以 $n$ 

## 实现细节

- 如果我们直接递归来写的话，容易栈溢出，所以我们用自下而上的迭代来写
- 我们注意到假如算一个 $8$ 项多项式 $A=\{a_{0},a_{1},a_{2},a_{3},a_{4},a_{5},a_{6},a_{7}\}$ 时，我们有以下步骤
	- 第一次分解：$A_{even}=\{a_{0},a_{2},a_{4},a_{6}\}$ $A_{odd}=\{a_{1},a_{3},a_{5},a_{7}\}$
	- 第二次分解：$A_{even}$ 分解为 $\{a_{0},a_{4}\}$ 与 $\{a_{2},a_{6}\}$ ，$A_{odd}$ 被分解为 $\{a_{1},a_{5}\}$ 与 $\{a_{3},a_{7}\}$ 
	- 第三次分解：$\{a_{0},a_{4}\}$ 分解为 $\{a_{0}\}$ 与 $\{a_{4}\}$ ，依次类推
- 我们发现他们的位置变为了 $\{a_{0},a_{4},a_{2},a_{6},a_{1},a_{5},a_{3},a_{7}\}$ ，所以我们要对原序列进行依次位逆序置换，既例如位于下标为 $110$ 的数，换到 $011$ 的位置去，然后我们再自底向上地进行 $\log n$ 次计算，第一轮计算长度为 $2$ 的 DFT，第二轮合并成长度为 $4$ 的 DFT，以此类推
# 数论变化 NTT 
## FFT 的问题

- 至此，FFT 的基本步骤已经讲完了，但是我们发现 FFT 有个致命问题——精度问题
- 在计算机中，复数通常由两个浮点数表示，从而导致其存在误差，所以我们要换一种方法
## NTT 的解决方案

- 为了克服精度问题，我们现在需要一个能在整数域内执行，保证结果完全正确的 FFT
- NTT 的核心思想是将 FFT 的整个算法框架从复数域平移到整数模 $p$ 的有限域 $\mathbb{Z}_p$ 之中，在其中不存在任何精度问题
- 平移为什么能成功，让我们回到 FFT 中，我们用 $n$ 次单位根做变换是因为它的那几个特殊性质，并不依赖于具体数值，所以现在我们就要在有限域 $\mathbb{Z}_p$ 中找一个数 $g_{n}$ 使得其能扮演复数根 $\omega_{n}$ 的角色，且有其有的所有性质
## 原根

- 在有限域中，能完美模拟单位复数根性质的工具是**原根**
- 在模 $p$ 的乘法群中，如果一个元素 $g$ 的阶是 $\mu(p)=p-1$ ，那么称其为模 $p$ 的一个原根，这意味着 $\{g^{1},g^{2},...,g^{p-1}\}\mod p$ 恰好不重复地遍历了集合 $\{1,2,...,p-1\}$ 中的所有元素

>阶：指在一个群中，一个元素通过自身运算，回到起点所需要的最少次数
## NTT 对模数要求

- 为了在 $\mathbb{Z}_{p}$ 之中找到一个 $n$ 次单位根，既满足 $g_{n}^{n}\equiv 1\pmod{p}$ ，且对于所有v的 $1\le k<n,g_{n}^{k}\not\equiv 1\pmod{p}$ ，元素的阶必须整除群的大小，所以我们需要一个阶为 $n$ 的元素，而乘法群的大小为 $p-1$ ，所以 $n|(p-1)$ ，因此我们得选一个形如 $p=n\cdot k+1$ 的质数作为模数
- 在比赛中，最常用的 NTT 模数是 $p=998244353=119\times 2^{23}+1$ ，所以其支持长度 $n$ 直到 $2^{23}$ 的 NTT，这对于绝大部分情况都完全够用，而其最小原根是 $3$ 
- 一旦我们有了满足条件的质数 $p=k\cdot n+1$ 与模 $p$ 的原根 $g$ ，我们就可以构造出所需要的 $n$ 次单位根 $g_{n}$ ：
$$g_{n}\equiv g^{k}\pmod{p}\equiv g^{(p-1)/n}\pmod{p}$$
- 可以证明其满足
$$\begin{cases}(g_{n})^{n}\equiv(g^{(p-1)/n}) ^{n}\equiv g^{p-1}\pmod{p}\\\\(g_{n})^{m}\not\equiv 1\pmod{p}\quad 1\le m<n\end{cases}$$
- 这个 $g_{n}$ 就是我们用的 $n$ 次单位根，它的逆元可以通过快速幂计算 $g_{n}^{p-2}\pmod{p}$ 
- 其周期性已验证，折半引理也易证，我们来验证对称性
	- 引理内容：$g_{n}^{k+\frac{n}{2}}=-g_{n}^{k}\pmod{p}$ 
		- 我们从左边开始推导 $g_{n}^{k+ \frac{n}{2}}=g_{n}^{k}\cdot g_{n}^{\frac{n}{2}}$ 
		- 其中 $(g_{n}^{\frac{n}{2}})^{2}=g_{n}^{2}\equiv 1\pmod{p}$ ，说明 $g_{n}^{\frac{n}{2}}$ 是模 $p$ 意义下 $1$ 的平方根，说明其只能是 $1$ 或者 $-1$ 
		- 根据定义 $g_{n}^{k}\not\equiv 1\pmod{p}\quad k<n$ ，所以其为 $-1$ ，得证
## 算法实现 

- 其过程与 FFT 完全相同，区别在于是在模 $p$ 的意义下进行
- 输入：一个系数向量 $a$ ，变换长度为 $n=2^{k}$ 
- 预处理：找到原根 $g$ ，计算主 $n$ 次根 $g_{n}\equiv g^{(p-1)/n}\pmod{p}$ 和逆元 $g_{n}^{-1}$ 
- 算法主体：
	- 对输入向量进行位逆序置换
	- 然后进行 $\log n$ 轮迭代，每轮迭代中：
		- 对当前所有块进行蝴蝶操作合并
		- 蝴蝶操作总的旋转因子是 $g_{n}$ 或者 $g_{n}^{-1}$ 的相应次幂
		- 所有运算在模 $p$ 意义下进行
	- 如果是逆变换，就要给每个元素都乘以 $n^{-1}$ 

# 模板

```cpp
void ntt(vector<ll>& a,int inv){
    int n=a.size();

    for (ll i = 1, j = 0; i < n; i++) {
        ll bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j)swap(a[i], a[j]);
    }

    for(ll len=2;len<=n;len<<=1){
        ll half=len/2;
        ll g=qpow(G,(mod-1)/len);
        if(inv) g=qpow(g,mod-2);

        for(ll i=0;i<n;i+=len){
            ll w=1;
            for(ll j=0;j<half;j++){
                ll x=a[i+j];
                ll y=(w*a[i+j+half])%mod;
                a[i+j]=(x+y)%mod;
                a[i+j+half]=(x-y+mod)%mod;
                w=(w*g)%mod;
            }
        }
    }

    if(inv){
        ll n_inv=qpow(n,mod-2);
        for(auto &x:a) x=(x*n_inv)%mod;
    }
}

vector<ll> mul(vector<ll>&a,vector<ll>&b){
    int len_a=a.size()-1,len_b=b.size()-1;
    int len=len_a+len_b;
    int n=1;

    while(n<len) n<<=1;

    a.resize(n);
    b.resize(n);

    ntt(a,0);
    ntt(b,0);

    vector <ll> c(n);

    f(i,0,n-1){
        c[i]=(a[i]*b[i])%mod;
    }

    ntt(c,1);
    c.resize(len+1);

    return c;
}
```