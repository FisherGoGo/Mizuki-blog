---
title: 快速莫比乌斯变换
published: 2025-07-29
tags: [MATH]
category: Knowledge
draft: false
---

- 之前讲过快速莫比乌斯反演，然而那个是对于数来进行的运算，我们回想那个式子：
$$f(n)=\sum\limits_{d|n} g(d)\Leftrightarrow g(n)=\sum\limits_{d|n} \mu\left( \frac{n}{d} \right)f(d)$$
- 那么 FMT 对应的是这个式子：
$$g(S)=\sum\limits_{T\in S} f(T)\Leftrightarrow f(S)=\sum\limits_{T\in S}(-1)^{|S|-|T|} g(T)$$
- 我们来讲如何进行正变换和逆变换

# 正变换
$$g(S)=\sum\limits_{T\in S} f(T)$$
- 我们有一个数组，它为某个全集 $U=\{0,1,\ldots ,n-1 \}$ 的每个子集 $S\in U$ 赋予一个值 $f(S)$ ，我们通常考虑用二进制来存储，其中第 $i$ 个下标代表一个子集 $S$ ，现在我们要算 $g$ 的值，这个 $g$ 函数一般称为 $f$ 的 $\mathbf{Zeta}$ 变化，有时候也可以称为满足集合为 $S$ 的子集的值的和
- 最直接的方法是我们对于每一个自己都遍历一边可能的子集，然后加上，这个复杂度是 $O(4^{n})$ 或者 $O(N^{2})$ 
- FMT 的精髓在于动态规划逐维逐位计算，我们将一个子集看作一个 $n$ 位的二进制数，算法迭代 $n$ 次，在第 $i$ 轮时，我们只考虑第 $i$ 位的影响，以下是具体步骤
	- 初始化一个新数组 $g$ ，其初始值与 $f$ 相同
	- 我们让 $i$ 从 $0$ 遍历到 $n-1$ 
	- 在第 $i$ 轮中，遍历所有子集 $S$ ，$S$ 从 $0$ 到 $2^{n}-1$ 
	- 检查 $S$ 的第 $i$ 位是否为 $1$ ，如果是，我们将 $S$ 去掉第 $i$ 位后得到的子集的值累加上，既 $g(S)=g(S)+g(S\oplus 2^{i})$ 
- 这个过程实际是在第 $i$ 轮后，加上所有只在前 $i$ 位可能不同的子集的 $f$ 的和，那么 $n$ 轮迭代后就可以得到答案

# 逆变换
$$f(S)=\sum\limits_{T\in S}(-1)^{|S|-|T|} g(T)$$
- 这时候我们想要还原出原始的 $f$ 数组，步骤与前边相同，只是把加法换成了减法：
	- 初始化一个新数组 $f$ ，其初始值与 $g$ 相同
	- 我们让 $i$ 从 $0$ 遍历到 $n-1$ 
	- 在第 $i$ 轮中，遍历所有子集 $S$ ，$S$ 从 $0$ 到 $2^{n}-1$ 
	- 检查 $S$ 的第 $i$ 位是否为 $1$ ，如果是，我们将 $S$ 去掉第 $i$ 位后得到的子集的值减去，既 $g(S)=g(S)-g(S\oplus 2^{i})$ 
- 这样子刚好抵消了前边的操作，从而还原出初始值

# 关联

- 关于为什么叫快速莫比乌斯变换，因为其是莫比乌斯反演的更广泛的版本，既可以维护任意偏序集的数学结构，此变换就是在集合上的运用