---
title: Summer Problem
published: 2025-08-18
tags: [DS]
category: Tutorial
draft: false
---

$$\text{夏の終わり}$$
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2710849639&auto=0&height=66"></iframe>

# 求树上多少条简单路径，其点集满足 $\mathbf{lcm(V)}$ 刚好为 $x$

- 2025.7.18 航电第一场 1007
- 我们定义以下函数：
$$f(x):简单路径\;\mathbf{lcm}\;为\;x\;的约数的个数$$
$$g(x):简单路径\;\mathbf{lcm}\;为\;x\;的个数$$
- 我们可以写出一下式子：
$$f(x)=\sum\limits_{d|x} g(d)$$
- 那么就是最基础的莫比乌斯反演，得到
$$g(x)=\sum\limits_{d|x} \mu\left( \frac{x}{d} \right)f(d)$$
- 统计 $f(x)$ 是简单的，并查集然后统计连通块大小即可
- 式子反演即可

# 夜世界 
## 来源

- 2025 杭电多校第一场 1002 
## 题面

- 有 $n$ 座金矿，你每天都会从金矿 $1$ 依次走到金矿 $n$ ，有 $m$ 天
- 每座金矿有属性 $a_{i},b_{i}$ ，当你到达金矿会先获得 $a_i$ 个金币，然后丢失 $b_{i}$ 个金币，如果数目不满 $b_{i}$ 就丢失全部金币
- 每天发生以下事件之一：
	- $\mathbf{Type \; 1}$ ：第 $x$ 座金矿的 $a_{i}$ 变为 $y$
	- $\mathbf{Type \; 2}$ ：第 $x$ 座金矿的 $b_{i}$ 变为 $y$
	- $\mathbf{Type \; 3}$ ：所有金矿的情况变为跟第 $x$ 天一样
	- $\mathbf{Type\; 4}$ ：有 $k$ 座金矿，你今天经过这座金矿时会丢失 $\left\lceil\dfrac{\mathbf{sum}}{2}\right\rceil$ ，其中 $\mathbf{sum}$ 是你此时有的金币，你依旧会先获得金币，对于此事件，你需要回答你今天会丢失多少金币
## 题解

- 我们设 $f_{i}$ 为到第 $i$ 座金矿时完成获取和丢失后剩下的金币
- 那么有：
$$f_{i}=\max(f_{i-1}+a_{i}-b_{i},0)$$
- 我们现在定义：
$$\begin{cases}a\oplus b=\max(a,b) \\ a\otimes b=a+b\end{cases}$$
- 那么我们有：
$$\begin{vmatrix}f_{i}\\0\end{vmatrix}=\begin{vmatrix}a_{i}-b_{i}&0\\-\infty&0\end{vmatrix} \begin{vmatrix}f_{i-1}\\0\end{vmatrix}$$
- 其中在矩阵乘法中所有的 $+$ 被换成 $\oplus$ ，$\times$ 被换成 $\otimes$ 
- 我们再定义：
$$A_{i}=\begin{vmatrix}a_{i}-b_{i}&0\\-\infty& 0\end{vmatrix}$$
- 那么走完后剩的钱为：
$$f_{n}=A_{n}\cdot A_{n-1}...A_{1}\cdot f_{0}$$
- 我们可以线段树维护这个矩阵并且可持久化
- 如果 $d_{x}$ 管理的区间是 $[l,r]$ ，那么：
$$d_{x}=A_{r}\cdot A_{r-1}...A_{l}$$
- 那么我们维护区间就是
$$d_{x}=d_{rs_{x}}\cdot d_{ls_{x}}$$
> 注意是右儿子**左乘**左儿子

- 那么对于操作四我们直接暴力求出所有一般区间然后对于特殊点直接算就行
- 总复杂度 $O(n+2m\log n)$ 

# 苹果树

## 来源

- 2025 杭电多校第二场 1009

## 内容

- 我有一颗树，有两个操作：
	- 查询节点 $x$ 到节点 $y$ 的最大值
	- 修改与节点 $x$ 连接的所有点 $i$ ，使 $a_i=a_i+z$

## 题解

- 我们考虑使用重链剖分来维护这个最大值信息，查询是简单的
- 对于操作二，我们修改的节点涉及：父亲，重儿子，轻儿子
- 对于父亲和重儿子我们直接修改，对于轻儿子我们把信息存在 $x$ 节点，打一个前缀和，表示前 $k$ 个操作之和，我们在查询的时候修改
- 我们在查询时会跳链，在查询这条链之前我们先看链顶的父亲有没有操作存储，如果有的话就加上然后查询
- 关于前缀和：由于每次查询修改时加的值的时间上的区间不一样，所以我们用前缀和来加速和维护要加的时间区间

# $\mathbf{Head\;out\;to\;the\;Target}$

## 题面

- 给一棵树，一个棋子开始在根节点 $1$ ，有 $k$ 个不重叠时间区间，对于 $l_{i},r_{i},u_{i}$ ，表示在时间区间 $[l_{i},r_i]$ 内在点 $u$ 有一个目标
- 如果树上存在一个目标，棋子每秒会进行以下操作
	- 如果目标存在且与 $u$ 在同一连通块，并且棋子与它不在同一点，那么棋子会向目标唯一简单路径走一步
	- 如果棋子与目标在同一点，称为重合，那么结束
- 然后你可以在任意时刻切掉任意数量的边
- 求最快什么时候可以重合，如果永远无法重合就输出 $-1$ 

## 题解

- 对于任何可以去到的点，我们都可以作为出发点出发，因为我们永远可以构造出一个切割方案过去，那么我们对图染色
- 当前考虑 $l_{i},r_{i},u_{i}$ 
	- 先在已经染过色的点中找离 $u_{i}$ 最近的点 $v_{i}$
	- 如果距离小于时间那么就可以输出答案
	- 反之我们向 $v_{i}$ 到 $u_{i}$ 的路径长度为 $r-l+1$ 的路染色，以便下一次使用
- 树剖加倍增即可
- 赛后 MenG 提醒到每个点最多被访问一次，所以没必要线段树，直接倍增即可

# $\mathbf{Echoes\;of\;24}$

## 题面

- 牛客多校第四场 E
- 给一颗树，有两个操作
	- 把一个节点的权值改为给定值
	- 给定 $l,r$ ，询问若开始有一个 $a_{l}$ ，从 $l$ 走到 $r$ ，每次遇到一个数就加上或者乘上，走到终点能不能凑成 $24$ 
## 题解

- 虽然比赛给的刁钻的空间限制卡死了这道题用树剖加线段树的做法，但是其实最后的空间也才用了 $400M$ 左右，这对于一道数据结构题来说十分常见
- 我们定义一个矩阵 $T$ ，其中若 $T_{ij}=1$ 表示进来一个数 $i$ 可以转化为 $j$ ，那我们目标就是求出 $l$ 到 $r$ 的路上不含 $l$ 的变换矩阵，然后查看 $T_{a_{l},24}$ 是否为 $1$ 就行
- 我们考虑树剖加线段树维护，矩阵相乘中的加换成或运算，乘换成且运算，既
$$T_{ij}=\lor(D_{ik}\land D_{kj})$$
- 注意维护一个 $T_{ls}\times T_{rs}$ 和 $T_{rs}\times T_{ls}$ ，分别是向下走和向上走的变化矩阵

# 求和

## 题面

- 杭电第三场 1001
- 给一个长度为 $k$ 的正整数序列 $a_{1},a_{2},...,a_{k}$ ，以及包含 $n$ 个数的多重集合 $S$ ，定义函数
$$f(n)=\begin{cases}0,\;n\le 1\\\\1,\; n=0\\\\ \sum\limits_{i=1}^{k} f(n-i) a_{i},\; n\ge 1\end{cases}$$
- 我们要计算：
$$\sum\limits_{T\in S} f(\sum\limits_{x\in T} x)\pmod{998244353}$$
## 题解

- 观察式子，发现就是一个很常见的一个 $k$ 阶递推式，用[矩阵](https://fishergogo.github.io/2025/07/27/Matrix_Operations_and_Linear_Recurrence_Relations/)来求，对于任意 $f(n)$ 都可以用矩阵快速幂在 $O(\log n)$ 内求出
- 那对于原来的式子，我们可以化成：
$$\sum\limits_{T\in S} M^{\sum\limits_{x\in T} x}\cdot v_{0}$$
- 对于前边那个式子，可以巧妙地化为：
$$\prod_{b\in S}(M^{0}+M^{b})=\prod_{b\in S}(I+M^{b})$$ 
# Perfect Journey
## 题面

- 牛客多校第五场 K
- 一颗树，有 $m\le 22$ 条关键路径，有 $k$ 条 $s_{i}$ 到 $t_{i}$ 的路线，问最少要几条路线可以经过所有关键路径，且求出方案数
## 题解

- $m$ 很小，考虑状态压缩
- 我们先求出 $way_i$ 表示第 $i$ 条路线经过那些关键路径，可以通过 $dp_{s}\oplus dp_{t}$ 快速得出，$dp_{i}$ 表示从根走到点 $i$ 经过哪些路径的二进制值， $O(n)$ 即可求出
- 然后我们定义 $F_{i}$ 表示状态是 $i$ 的子集有多少条路，这个可以用 [FWT](https://fishergogo.github.io/2025/07/29/FWT/) 得出
- 然后我们枚举选的路线，可以发现我们最多选 $m$ 条路，否则无解
- 我们定义 $g_{i}$ 为选出来的路径状态或之和为 $i$ 的子集的方案数，当我们选 $c$ 条路时 $g_i=C(F_{i},c)$ ，然后定义 $f_{i}$ 为选出来的路径状态或之和刚好为 $i$ 的方案数，用 IFWT 求出即可 
- 单纯从 $1$ 枚举到 $m$ 复杂度是 $O(m^{2}2^{m})$ ，会超时，我们再考虑二分答案，复杂度来到 $O(m2^{m}\log m)$ ，可以通过

# cats 的 max
## 题面

- 杭电多校第六场 1008
- 给定一个 $n\times m$ 的矩阵，从里边选 $k$ 行，求
$$\sum\limits_{i=1}^{m}\max\{a_{p_{1},i},a_{p_{2},i},\ldots,a_{p_{k},i}\}$$
- 其中 $n,k\le 1000,m\le 13$
## 题解

- 发现 $m$ 很小，考虑状态压缩
- 我们可以指定选出来的行中某一行的某一列作为这一列的最大值，如果被选中就是 $1$ 否则是 $0$ ，会发现答案就是由 $k$ 个不相交的二进制方案得来，保证选了 $k$ 个状态的方案中选了小于等于 $k$ 行
- 我们考虑对于每一个状态取 $\max$ ，然后跑 DP ，设 $dp_{i,k}$ 表示选了 $i$ 个状态时状态 $k$ 的最大值，可以这样子递推
$$dp_{i,k}=\max_{j\in i}\{dp_{i-1,j}+row_{j\oplus i}\}$$
# 钥匙迷宫
## 题面

- 杭电多校第六场 1005
- 有一个有 $2n$ 个节点的树，有 $n$ 个门和钥匙，散落在 $2n$ 个点上，我们只有得到钥匙才能经过对应得门的节点，问对于每一个有钥匙的节点出发能不能得到所有钥匙
## 题解

- 结论：能出发的节点一定是在一个连通块里，这里的连通块是指删掉那些门在的节点之后的森林，可以证明，当答案是在两个连通块之间时，一定有一个连通块无法到达另外一个连通块，矛盾；对于一对钥匙和门，我们只能在以门为根时钥匙在的那个子树出发
- 可以发现就是对 $n$ 对钥匙和门取交集，最后的集合就是可能答案所在的集合，我们再以此为出发点做一遍bfs验证即可
- 对于取交集的操作，树上差分即可

# 最甜的小情侣
## 题面

- 杭电多校第八场 1006
- 有 $n$ 个点连成的环，每个点有点权，要求选出最大点权和点集，且点集中不能有三个以上连续的点，且有 $q$ 次单点修改，要求每次修改后给出最大点权和
## 题解

- 考虑线性递推 DP ，设 $dp_{i,j}$ 表示在第 $i$ 个点结尾有连续 $j$ 个点被选中，有以下递推
$$\begin{cases}dp_{i,0}=\max\{dp_{i-1,0},dp_{i-1,1},dp_{i-1,2},dp_{i-1,3}\}\\ dp_{i,1}=dp_{i-1,0}+w_{i}\\dp_{i,2}=dp_{i-1,1}+w_{i}\\dp_{i,3}=dp_{i-1,2}+w_{i}\end{cases}$$
- 转 为 $\mathbf{max-plus}$ 矩阵，设 $DP_{i}$ 为第 $i$ 个dp矩阵，为行向量
$$DP_{i}=DP_{i-1}\cdot \begin{vmatrix}0&w_{i}&-\inf&-\inf\\0&-\inf&w_{i}&-\inf\\0&-\inf&-\inf&w_{i}\\0&-\inf&-\inf&-\inf\end{vmatrix}$$
- 用线段树去维护单点修改即可
- 对于环的问题，我们枚举第 $1,2,3,n$ 个点不选即可

# 排列
## 题面

- 牛客多校第九场 G
- 给定一个排列 $p$ ，操作恰好 $n$ 次，可选操作如下：
	- 删除 $p$ 最左边的数
	- 删除 $p$ 最右边的数
	- 将 $p$ 中最小值加入序列 $a$ ，此操作不改变 $p$ 
- 问能组成多少种序列 $a$ 
## 题解

- 我们在笛卡尔树上看这个序列
	- 笛卡尔树：按照中序遍历可以还原这个序列，根节点为序列最小值
- 我们发现我们要加入下一个最小值需要删除这个树的一半，我们从树往下遍历，加入遍历到了 $x$ ，经过了 $k$ 个数，删除了 $w$ 个点，我们还剩下 $n-w$ 次操作，那就是在 $k$ 个数可重复地选 $n-w$ 个的方案数，用插板法解决
- 但是我们还可以浪费一些操作去删点，且为了去重，我们固定此时的方案最后一个必须是 $x$ ，那么就是在 $k+1$ 个数可重复地中选 $n-w-1$ 个，其中 $+1$ 是为了计算浪费了的操作

# 老师与好感度
## 题面

- 牛客第十场 E
- 给定一个序列，每次可以让一段连续的数加 $1$ ，问最少要几次可以使得序列中至多存在 $w$ 种数
-  $0\le a_{i}\le 100,n\le 100 ,1\le m\le 2$
## 题解

- 对于一个序列，加入我们要把他们加到 $b_{i},b_{i}\ge a_{i}$ ，构建差分数组 $c_{i}=b_{i}-a_{i}$ ，那么最少次数是 $c_{1}+\sum\limits_{i=2}^{n}\max\{0,c_{i}-c_{i-1}\}$ 
- 如果 $m=1$ ，我们令所有值都加到最大值，然后跑公式即可
- 否则我们枚举最大值和次大值，设 $dp_{i,0/1}$ 表示第 $i$ 个位置加到次大值/最大值的最小次数
- 那么就有转移公式
$$\begin{cases} 
dp_{i,1}=\min\{dp_{i-1,1}+\max\{0,c_{i,1}-c_{i-1,1},dp_{i-1,0}+\max\{0,c_{i,1}-c_{i-1,0}\}\}\}\\ \\
dp_{i,0}=\min\{dp_{i-1,1}+\max\{0,c_{i,0}-c_{i-1,1},dp_{i-1,0}+\max\{0,c_{i,0}-c_{i-1,0}\}\}\}\end{cases}$$
- 注意只有比次小值小才能转移到或者从最小值转移出去

# 老师和 Yuuka 逛商场
## 题面

- 给定一个序列，要求找到分割点使得序列分成三段且每三段的元素集合去重后交集最大
## 题解

- 枚举第一部分与第二部分的分割点，考虑在剩下区域 $\log N$ 内找到第二部分与第三部分分割点
- 发现若把区间内一个元素首次出现与最后一次出现的位置画一条线段，那么最佳位置就是被最多线段覆盖的点，那么就是线段树维护区间加减与最大值然后二分找最大值
- 我们预处理每一个位置下一个相同的值的下标与每一个元素最后一次出现的位置
- 移动左端点时若加进来一个第一部分没有的元素，找到下一个位置 $i$ 与最后一次出现的位置 $j$ ，在 $[i+1,j]$ 区间加 $1$ ，若进来一个出现过的元素，当前位置为 $i$ ，找到下一个位置 $j$  ，在 $[i+1,j]$ 区间减 $1$ ，然后二分查找最大值位置

# 乘法逆元
## 题面

- 求以下式子
$$\oplus_{i=1}^{p-1}(inv(i)+2^{k})\cdot (i+4^{k})\quad k=\left\lceil \frac{p}{119}\right\rceil$$
- 其中 $p\le 10^{12}$ 为素数，答案对 $998244353$ 取模
## 题解

- 考虑展开这个式子
$$inv(i)\cdot i+i\cdot 2^{k}+inv(i)\cdot 4^{k}+2^{3k}$$
- 发现当 $k$ 比较大时式子里 $4$ 部分异或和互不干扰，我们单独计算即可
- 对于 $inv(i)\cdot i$ ，由于 $inv(inv(i))=i$ 所以除了 $1$ 与 $p-1$ 之外两两对应，异或完为 $0$ ，剩下 $(p-1)^{2}\oplus 1$ ；然后对于之间两部分就是 $\oplus_{i=1}^{p-1} i$ ，模 $4$ 分类讨论即可；最后一部分看 $p-1$ 奇偶性即可
- 当 $k$ 比较小时暴力算，打表出这个分治点大约为 $2740$ 左右
